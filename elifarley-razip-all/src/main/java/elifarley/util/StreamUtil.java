/* StreamUtil -- Utility functions to work with VersaStreams.Portions of this software are Copyright (c) 2001, Elifarley Callado Coelho -http://www.geocities.com/elifarley/LicenseRedistribution and use in source and binary forms,with or without modification, are permitted provided thatthe following conditions are met:*	Redistributions of source code must retain the abovecopyright notice, this list of conditions and the followingdisclaimer. *	Redistributions in binary form must reproduce the abovecopyright notice, this list of conditions and the followingdisclaimer in the documentation, about box and/or othermaterials provided with the distribution. *	No personal names or organizations names associatedwith the Indy project may be used to endorse or promoteproducts derived from this software without specific priorwritten permission of the specific individual ororganization. THIS SOFTWARE IS PROVIDED BY ITS AUTHOR (ELIFARLEY CALLADO COELHO) "AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */package elifarley.util;import elifarley.io.*;import java.io.Reader;import java.io.Writer;import java.io.DataInput;import java.io.DataInputStream;import java.io.DataOutput;import java.io.InputStream;import java.io.OutputStream;import java.io.EOFException;import java.io.IOException;public class StreamUtil {    public static final int MAXBUFSIZE = 65536;    public static long copy(VersaStream source, VersaStream dest, long count) throws IOException {        /*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from beginning up to the end. Source may be asked to seek backwards         */        long result = 0;        byte buffer[];        if (source instanceof MemoryVersaStream) {            synchronized (source) {                MemoryVersaStream mvs = (MemoryVersaStream) source;                if (count == 0) {                    count = source.getSize() - source.getPosition();                }                byte buf[] = mvs.getBuffer();                synchronized (dest) {                    dest.write(buf, (int) source.getPosition(), (int) count);                }            }            return count;        }        synchronized (source) {            synchronized (dest) {                if (count < 0) {                    if (source.getPosition() != 0) {                        source.setPosition(0);                    }                    count = 0;                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new byte[bufSize];                int i;                if (count == 0) // We need to copy the whole source                {                    while ((i = source.read(buffer, 0, bufSize)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                    }                } else // We need to copy up to count bytes                {                    while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int) count)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                        count -= i;                    }                }            }        }        buffer = null;        return result;    }    public static long copy(DataInput source, VersaStream dest, long count) throws IOException {        /*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from last marked position up to the end. Source will be asked to reset         */        long result = 0;        byte buffer[];        if (source instanceof MemoryVersaStream) {            synchronized (source) {                MemoryVersaStream mvs = (MemoryVersaStream) source;                if (count == 0) {                    count = mvs.getSize() - mvs.getPosition();                }                byte buf[] = mvs.getBuffer();                synchronized (dest) {                    dest.write(buf, (int) mvs.getPosition(), (int) count);                }            }            return count;        }        synchronized (source) {            synchronized (dest) {                if (count < 0 && !(source instanceof VersaStream)) {                    throw new IOException("Copying from beginning not supported with DataInput");                } else {                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new byte[bufSize];                int i;                if (count == 0) {                    while ((i = source.readByte()) != -1) {                        dest.write(i);                        result++;                    }                } else {                    while (count > 0 && (i = source.readByte()) != -1) {                        dest.write(i);                        result++;                        count--;                    }                }            }        }        buffer = null;        return result;    }    public static long copy(InputStream source, VersaStream dest, long count) throws IOException {        /*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from last marked position up to the end. Source will be asked to reset         */        long result = 0;        byte buffer[];        synchronized (source) {            synchronized (dest) {                if (count < 0) {                    //throw new IOException("Copying from beginning not supported with InputStreams");                    source.reset();                    count = 0;                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new byte[bufSize];                int i;                if (count == 0) {                    while ((i = source.read(buffer, 0, bufSize)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                    }                } else {                    while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int) count)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                        count -= i;                    }                }            }        }        buffer = null;        return result;    }    public static long copy(Reader source, VersaStream dest, long count) throws IOException {        /*   			count > 0 : copies from current position at most count bytes   			count = 0 : copies from current position up to the end   			count < 0 : copies from last marked position up to the end. Source will be asked to reset         */        long result = 0;        char buffer[];        synchronized (source) {            synchronized (dest) {                if (count < 0) {                    //throw new IOException("Copying from beginning not supported with InputStreams");                    source.reset();                    count = 0;                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new char[bufSize];                int i;                if (count == 0) {                    while ((i = source.read(buffer, 0, bufSize)) != -1) {                        dest.writeChars(new String(buffer).substring(0, i));                        result += i;                    }                } else {                    while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int) count)) != -1) {                        dest.writeChars(new String(buffer).substring(0, i));                        result += i;                        count -= i;                    }                }            }        }        buffer = null;        return result;    }    public static long copy(VersaStream source, DataOutput dest, long count) throws IOException {        long result = 0;        byte buffer[];        synchronized (source) {            synchronized (dest) {                if (count < 0) {                    if (source.getPosition() != 0) {                        source.setPosition(0);                    }                    count = 0;                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new byte[bufSize];                int i;                if (count == 0) {                    while ((i = source.read(buffer, 0, bufSize)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                    }                } else {                    while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int) count)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                        count -= i;                    }                }            }        }        buffer = null;        return result;    }    public static long copy(VersaStream source, OutputStream dest, long count) throws IOException {        long result = 0;        byte buffer[];        synchronized (source) {            synchronized (dest) {                if (count < 0) {                    if (source.getPosition() != 0) {                        source.setPosition(0);                    }                    count = 0;                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new byte[bufSize];                int i;                if (count == 0) {                    while ((i = source.read(buffer, 0, bufSize)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                    }                } else {                    while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int) count)) != -1) {                        dest.write(buffer, 0, i);                        result += i;                        count -= i;                    }                }            }        }        buffer = null;        return result;    }    public static long copy(VersaStream source, Writer dest, long count) throws IOException {        //return copyTo(new OutputStreamWriter(dest), count);        long result = 0;        byte buffer[];        synchronized (source) {            synchronized (dest) {                if (count < 0) {                    if (source.getPosition() != 0) {                        source.setPosition(0);                    }                    count = 0;                }                int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int) count;                buffer = new byte[bufSize];                int i;                if (count == 0) {                    while ((i = source.read(buffer, 0, bufSize)) != -1) {                        dest.write(new String(buffer).substring(0, i));                        result += i;                    }                } else {                    while (count > 0 && (i = source.read(buffer, 0, count > bufSize ? bufSize : (int) count)) != -1) {                        dest.write(new String(buffer).substring(0, i));                        result += i;                        count -= i;                    }                }            }        }        buffer = null;        return result;    }    /*    public synchronized long copyTo(String dest, long count) throws IOException {		// it will not work !!!!!!!  		if (count < 0) {  			if (this.getPosition() != 0) this.setPosition(0);  			count = 0;  		}		int bufSize = (count == 0 || count > MAXBUFSIZE) ? MAXBUFSIZE : (int)count;  		byte buffer[] = new byte[bufSize];  		  		int i;   		long result = 0;  		StringBuffer sb = new StringBuffer();  		  		if (count==0)   			while ((i = this.read(buffer, 0, bufSize)) != -1) {				sb.append(new String(buffer, 0, i));				result += i;	    	}	    else  			while (count > 0 && (i = this.read(buffer, 0, count > bufSize ? bufSize : (int)count)) != -1) {				sb.append(new String(buffer, 0, i));				result += i;				count -= i;	    	}	  		  		buffer = null;  		// it does not work !!!!!  		dest = sb.toString();  		// !!!!!!!!!!!!!!!!!!!!!!  		sb = null;  		return result;					}	    public synchronized final long copyTo(String dest) throws IOException {		return copyTo(dest, -1);	}     */}