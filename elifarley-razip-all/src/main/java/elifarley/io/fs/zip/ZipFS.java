/* ZipFS -- Exposes a ZIP file as a ZIP file system. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */package elifarley.io.fs.zip;import elifarley.io.fs.VersaFS;import elifarley.io.fs.VersaFSEntry;import elifarley.io.VersaStream;import elifarley.io.InflaterVersaStream;import elifarley.io.VersaStreamFactory;import java.util.Date;import java.io.IOException;import java.io.InputStream;import java.util.Enumeration;import java.util.Hashtable;import java.util.zip.ZipException;import java.util.zip.Inflater;public class ZipFS extends VersaFS implements ZipConstants {    protected VersaStream vs;    protected String name = "";    protected Hashtable entries;    protected long cenpos;    protected long endpos;    public ZipFS(VersaStream vs) throws IOException {        this.vs = vs;        scanEntries();    }    public String getDataSourceName() {        return name;    }    public VersaFSEntry getEntry(String entryName) throws IOException {        VersaFSEntry result = (VersaFSEntry) entries.get(entryName);        if (result == null) {            throw new ZipException("Entry \'" + entryName + "\' not found");        }        return result;    }    public Date getCreationDate(VersaFSEntry vfse) throws IOException {        return null;    }    public void setCreationDate(VersaFSEntry vfse, Date date) throws IOException {    }    public Date getModificationDate(VersaFSEntry vfse) throws IOException {        return null;    }    public void setModificationDate(VersaFSEntry vfse, Date date) throws IOException {    }    public long getSize(VersaFSEntry vfse) throws IOException {        ZipEntry ze = entries.get(vfse.getName());        if (ze == null) {            throw new IOException("File not found: " + vfse.getName());        }        return ze.size;    }    public final synchronized void setSize(VersaFSEntry vfse, long newSize) throws IOException {        if (!(vfse instanceof ZipEntry)) {            throw new IllegalArgumentException("Not a zip entry");        }        if (newSize == vfse.getSize()) {            return;        }        try {            vs.replace(((ZipEntry) vfse).getOffset(), vfse.getSize(), (int) newSize);        } catch (IOException ioe) {        }        ((ZipEntry) vfse).size = newSize;    }    public boolean isDirectory(VersaFSEntry vfse) {        return vfse.getName().endsWith("/");    }    public void rm(VersaFSEntry vfse) throws IOException {        throw new IOException("Not yet implemented");    }    public void rmdir(VersaFSEntry vfse) throws IOException {        throw new IOException("Not yet implemented");    }    public void cp(VersaFSEntry vfseFrom, VersaFSEntry vfseTo) throws IOException {        throw new IOException("Not yet implemented");    }    public void mv(VersaFSEntry vfseFrom, VersaFSEntry vfseTo) throws IOException {        throw new IOException("Not yet implemented");    }    public void mkdir(VersaFSEntry vfse) throws IOException {        throw new IOException("Not yet implemented");    }    public VersaStream getVersaStream(VersaFSEntry vfse) throws IOException {        ZipEntry ze = (ZipEntry) vfse;        InputStream in = new ZipFSInputStream(this, ze);        switch (ze.method) {            case ZipEntry.ZCM_STORED:                return VersaStreamFactory.getVersaStream(in);            case ZipEntry.ZCM_DEFLATED:                return new InflaterVersaStream(in, new Inflater(true));            default:                throw new ZipException("invalid compression method");        }    }    public Enumeration<ZipEntry> entries() {        return entries.elements();    }    public void close() throws IOException {        if (vs != null) {            vs.close();            vs = null;        }    }    public long getCount() {        return entries.size();    }    private void scanEntries() throws IOException {        throw new IOException("Not yet implemented");    }}class ZipFSInputStream extends InputStream implements ZipConstants {    protected ZipFS zfs;    protected ZipEntry ze;    protected long origCount, count, origPos, pos;    ZipFSInputStream(ZipFS zfs, ZipEntry ze) throws IOException {        this.zfs = zfs;        this.ze = ze;        init();    }    public int available() {        return (int) Math.min(count, Integer.MAX_VALUE);    }    public int read(byte b[], int off, int len) throws IOException {        if (count == 0) {            return -1;        }        if (len > count) {            len = (int) Math.min(count, Integer.MAX_VALUE);        }        len = zfs.vs.read(pos, b, off, len);        if (len == -1) {            throw new ZipException("premature EOF");        }        pos += len;        count -= len;        return len;    }    public int read() throws IOException {        if (count == 0) {            return -1;        }        int n = zfs.vs.read(pos);        if (n == -1) {            throw new ZipException("premature EOF");        }        pos += 1;        count -= 1;        return n;    }    public long skip(long n) {        if (n > count) {            n = count;        }        pos += n;        count -= n;        return n;    }    public void reset() {        count = origCount;        pos = origPos;    }    private void init() throws IOException {        throw new IOException("Not yet implemented");        //reset();    }}