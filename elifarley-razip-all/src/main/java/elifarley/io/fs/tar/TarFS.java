/* TarFS -- Exposes a TAR file as a TAR file system. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */package elifarley.io.fs.tar;import elifarley.io.fs.VersaFS;import elifarley.io.fs.VersaFSEntry;import elifarley.io.VersaStream;import elifarley.io.VersaStreamFactory;import java.util.Date;import java.io.EOFException;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.Enumeration;import java.util.Hashtable;/** * This class can be used to read the contents of a tar file. * * @version	1.0, 01/11/01 * @author	Elifarley C. Coelho */public class TarFS extends VersaFS implements TarConstants {    VersaStream vs;    private String name = "";    private Hashtable<String, TarEntry> entries;    //long cenpos;    //private long endpos;    private long count = -1;    public TarFS(VersaStream vs) throws IOException {        this.vs = vs;        scanEntries();    }    /**     * Opens a tar file for reading given the specified file name.     *     * @param name the name of the tar file     * @exception tarException if a tar format error has occurred     * @exception IOException if an I/O error has occurred     */    public TarFS(String name) throws IOException {        this(VersaStreamFactory.getVersaStream(name, "r"));        this.name = name;    }    public TarFS(File file) throws TarException, IOException {        this(file.getPath());    }    public String getDataSourceName() {        return name;    }    public VersaFSEntry getEntry(String entryName) throws IOException {        VersaFSEntry result = entries.get(entryName);        if (result == null) {            throw new TarException("Entry \'" + entryName + "\' not found");        }        return result;    }    public Date getCreationDate(VersaFSEntry vfse) throws IOException {        return null;    }    public void setCreationDate(VersaFSEntry vfse, Date date) throws IOException {    }    public Date getModificationDate(VersaFSEntry vfse) throws IOException {        return ((TarEntry) vfse).mTime;    }    public void setModificationDate(VersaFSEntry vfse, Date date) throws IOException {    }    public long getSize(VersaFSEntry vfse) throws IOException {        TarEntry te = entries.get(vfse.getName());        if (te == null) {            throw new IOException("File not found: " + vfse.getName());        }        return te.size;    }    public final synchronized void setSize(VersaFSEntry vfse, long newSize) throws IOException {        if (!(vfse instanceof TarEntry)) {            throw new IllegalArgumentException("Not a tar entry");        }        if (newSize == vfse.getSize()) {            return;        }        try {            vs.replace(((TarEntry) vfse).getOffset(), vfse.getSize(), (int) newSize);        } catch (IOException ioe) {        }        ((TarEntry) vfse).size = newSize;    }    public boolean isDirectory(VersaFSEntry vfse) {        return vfse.getName().endsWith("/");    }    public void rm(VersaFSEntry vfse) throws IOException {        throw new IOException("Not yet implemented");    }    public void rmdir(VersaFSEntry vfse) throws IOException {        throw new IOException("Not yet implemented");    }    public void cp(VersaFSEntry vfseFrom, VersaFSEntry vfseTo) throws IOException {        throw new IOException("Not yet implemented");    }    public void mv(VersaFSEntry vfseFrom, VersaFSEntry vfseTo) throws IOException {        throw new IOException("Not yet implemented");    }    public void mkdir(VersaFSEntry vfse) throws IOException {        throw new IOException("Not yet implemented");    }    public VersaStream getVersaStream(VersaFSEntry vfse) throws IOException {        return new TarFSVersaStream(this, (TarEntry) vfse);    }    public long getCount() {        return count;    }    public InputStream getInputStream(TarEntry te) throws IOException {        return new TarFSInputStream(this, te);    }    public Enumeration<TarEntry> entries() {        return entries.elements();    }    public String list() {        return entries.toString();    }    public void close() throws IOException {        if (vs != null) {            vs.close();            vs = null;        }    }    private void scanEntries() throws IOException {        entries = new Hashtable<String, TarEntry>(11000);        count = loadFromStream(vs, entries);    }    //count = entries.size();    public long loadFromStream(VersaStream vs, Hashtable<String, TarEntry> ht) throws IOException {        byte tempbuf[] = new byte[BLOCKSIZE];        //boolean endReached = false;        long p = 0;        TarEntry e;        long count = 0;        try {            while (true) {                //System.out.println("p: " + p);                vs.setPosition(p);                try {                    vs.readFully(tempbuf, 0, BLOCKSIZE);                } catch (EOFException eofe) {                    System.out.println("last p: " + p);                    break;                }                e = new TarEntry(this);                if (!e.loadFromBuffer(tempbuf)) {                    break;                }                e.setOffset(p + BLOCKSIZE);                ht.put(e.getName(), e);                /*				System.out.println("e: " + e);				System.out.println("TypeFlag:" + (char)e.typeFlag);				System.out.println("Size:" + e.size);				System.out.println("offset:" + e.offset);				if(e.typeFlag==DIRTYPE)					System.out.println("Its a dir!");                 */                p += BLOCKSIZE + ((e.getTypeFlag() == DIRTYPE || e.getSize() == 0) ? 0 : ((e.getSize() - 1) / BLOCKSIZE + 1) * BLOCKSIZE);                e = null;                count++;            }        } catch (Exception ex) {            ex.printStackTrace();        }        //count = entries.size();        return count;    }}class TarFSInputStream extends InputStream implements TarConstants {    private final TarFS tf;    private final TarEntry te;    private long pos;    private long count;    TarFSInputStream(TarFS tf, TarEntry te) throws IOException {        this.tf = tf;        this.te = te;        initEntry();    }    public int available() {        return (int) Math.min(count, Integer.MAX_VALUE);    }    public int read(byte b[], int off, int len) throws IOException {        if (count < 1) {            return -1;        }        if (len > count) {            len = (int) Math.min(count, Integer.MAX_VALUE);        }        len = tf.vs.read(pos, b, off, len);        if (len == -1) {            throw new TarException("premature EOF");        }        pos += len;        count -= len;        return len;    }    public int read() throws IOException {        if (count < 1) {            return -1;        }        int n = tf.vs.read(pos);        if (n == -1) {            throw new TarException("premature EOF");        }        pos++;        count--;        return n;    }    public long skip(long n) {        if (n > count) {            n = count;        }        pos += n;        count -= n;        return n;    }    private void initEntry() throws IOException {        // Get length and position of entry data        count = te.getSize();        pos = te.getOffset();    }}class TarFSVersaStream extends VersaStream implements TarConstants {    private final TarFS tf;    private final TarEntry te;    private long fPos, pos;    TarFSVersaStream(TarFS tf, TarEntry te) throws IOException {        this.tf = tf;        this.te = te;        fPos = 0;        pos = te.getOffset() + fPos;    }    public int read() throws IOException {        if (fPos >= te.getSize()) {            return -1;        }        int n = tf.vs.read(pos);        if (n == -1) {            throw new TarException("premature EOF");        }        fPos++;        pos++;        return n;    }    public int read(byte b[], int off, int len) throws IOException {        if (fPos >= te.getSize()) {            return -1;        }        int av = available();        if (len > av) {            len = (int) Math.min(av, Integer.MAX_VALUE);        }        len = tf.vs.read(pos, b, off, len);        if (len == -1) {            throw new TarException("premature EOF");        }        fPos += len;        pos += len;        return len;    }    public int available() {        int result = 0;        try {            result = (int) (te.getOffset() + te.getSize() - pos);        } catch (IOException ioe) {            ioe.printStackTrace();        }        return result;    }    public long getSize() throws IOException {        return te.getSize();    }    public final synchronized void setSize(long newSize) throws IOException {        tf.setSize(te, newSize);    }    public long getPosition() throws IOException {        return fPos;    }    public void setPosition(long pos) throws IOException {        if (te.getSize() <= pos) {            throw new IOException("Can't set position beyond end of stream");        }        fPos = pos;        this.pos = te.getOffset() + fPos;    }    public boolean canRead() {        return true;    }    public boolean canWrite() {        return false; // not yet    }    public boolean canSeekFromEnd() {        return true;    }    public boolean canSeekBackwards() {        return true;    }    public boolean canSeekForward() {        return true;    }    public boolean canSetSize() {        return true;    }    public long seek(long offset, short origin) throws IOException {        long p = 0;        switch (origin) {            case FROM_BEGINNING:                p = offset;                break;            case FROM_CURRENT:                p = fPos + offset;                break;            case FROM_END:                p = te.getSize() + offset;                break;            default:                throw new IOException("Invalid origin: " + origin);        }        if (te.getSize() <= p) {            throw new TarException("Can't set position beyond end of stream");        }        fPos = p;        this.pos = te.getOffset() + fPos;        return fPos;    }    public void write(int b) throws IOException {        throw new TarException("Writing not implemented");    }}