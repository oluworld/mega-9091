/* TarEntry -- Represents a tarFS entry. * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  */ package elifarley.io.fs.tar;import elifarley.io.fs.VersaFSEntry;import java.util.Date;/** * This class is used to represent a Tar file entry. * * @version	1.18, 01/24/97 * @author	Elifarley C. Coelho */publicclass TarEntry extends VersaFSEntry implements TarConstants {    private String linkName;    private String magic;    private String version;    //protected String name;    protected short mode;    protected int UID;    protected int GID;    protected long size = -1;    public Date mTime;    protected int chkSum;    protected byte typeFlag;    protected String UName;    protected String GName;    protected int devMajor;    protected int devMinor;    protected String prefix; // ??        protected long offset;        /**     * Creates a new Tar file entry with the specified name.     * @param name the entry name     * @exception NullPointerException if the entry name is null     * @exception IllegalArgumentException if the entry name is longer than     *		  0xFFFF bytes     */    /*    public TarEntry(String name) {	if (name == null) {	    throw new NullPointerException();	}	if (name.length() > 0xFFFF) {	    throw new IllegalArgumentException("entry name too long");	}	this.name = name;    }	*/	    /*     * Creates a new Tar file entry with no name.     */    TarEntry(TarFS tfs) {    	super(tfs);    }        public long getOffset() {		return offset;    }	    public void setOffset(long offset){    	this.offset = offset;    }        /**     * Sets the CRC-32 checksum of the uncompressed entry data.     * @param crc the CRC-32 value     * @exception IllegalArgumentException if the specified CRC-32 value is     *		  less than 0 or greater than 0xFFFFFFFF     */    public void setCrc(int crc) {	if (crc < 0 || crc > 0xFFFFFFFFL) {	    throw new IllegalArgumentException("invalid entry crc-32");	}	this.chkSum = crc;    }    /**     * Returns the CRC-32 checksum of the uncompressed entry data, or -1 if     * not known.     */    public long getCrc() {	return chkSum;    }	public byte getTypeFlag() {		return typeFlag;	}	public boolean loadFromBuffer(byte buf[]){		int i = 0, s = 0;		String sTemp;	    try{	    s = 100; this.name = new String(buf, i, s).trim(); i+= s;	    s = 8; sTemp = new String(buf, i, s).trim(); this.mode = sTemp.equals("")?0:(short)Integer.parseInt(sTemp, 8); i+= s;	    s = 8; sTemp = new String(buf, i, s).trim(); this.UID = sTemp.equals("")?0:Integer.parseInt(sTemp, 8); i+= s;	    s = 8; sTemp = new String(buf, i, s).trim(); this.GID = sTemp.equals("")?0:Integer.parseInt(sTemp, 8); i+= s;	    s = 12; sTemp = new String(buf, i, s).trim(); this.size = sTemp.equals("")?0:Integer.parseInt(sTemp, 8); i+= s;	    s = 12; sTemp = new String(buf, i, s).trim(); this.mTime = sTemp.equals("")?new Date(0):new Date(Integer.parseInt(sTemp, 8)); i+= s;	    if (this.mTime.getTime() == 0) if (checkEnd(buf)) return false;	    	    s = 8; sTemp = new String(buf, i, s).trim(); this.chkSum = sTemp.equals("")?0:Integer.parseInt(sTemp, 8); i+= s;	    s = 1; this.typeFlag = buf[i]; i+= s;	    //if (this.typeFlag < 0 || e.typeFlag > 7)	    //	System.err.println("Warning: file" + e.name + " has an unrecognized typeFlag (" + e.typeFlag + ")");	    	    s = 100; this.linkName = new String(buf, i, s).trim(); i+= s;	    s = 6; this.magic = new String(buf, i, s).trim(); i+= s;	    s = 2; this.version = new String(buf, i, s).trim(); i+= s;	    s = 32; this.UName = new String(buf, i, s).trim(); i+= s;	    s = 32; this.GName = new String(buf, i, s).trim(); i+= s;	    s = 8; sTemp = new String(buf, i, s).trim(); this.devMajor = sTemp.equals("")?0:Integer.parseInt(sTemp, 8); i+= s;	    s = 8; sTemp = new String(buf, i, s).trim(); this.devMinor = sTemp.equals("")?0:Integer.parseInt(sTemp, 8); i+= s;	    s = 155; this.prefix = new String(buf, i, s).trim(); // i+= s;	    }	    catch(NumberFormatException nfe){	    	nfe.printStackTrace();	    	System.out.println("Entry: " + this);	    	System.out.println("e.typeFlag: " + (char)this.typeFlag);	    }	    	    return true;	}			protected static boolean checkEnd(byte buf[]){		boolean b = true;			for (int i = 0; i < buf.length; i++)			if (buf[i] != 0) {b = false; break;}	 	return b;	}    }