/* TarConstants - Constants used by TarFS * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  * The constants were copied from the tar man pages found in LinuxPPC 2000. * I will add proper credits to the creators of the TAR format as soon as possible.  */package elifarley.io.fs.tar;/* * This interface defines the constants that are used by the classes * which manipulate tar files. * * @version	1.10, 11/24/96 * @author	David Connelly */interface TarConstants {    	String TMAGIC = "ustar" + Byte.parseByte("0");        /* ustar and a null */	int TMAGLEN = 6;	String TVERSION = "00";           /* 00 and no null */	int TVERSLEN = 2;	/* Values used in typeflag field.  */    byte REGTYPE = (byte)'0';            /* regular file */	byte AREGTYPE = 0;           /* regular file */	byte LNKTYPE  = (byte)'1';            /* link */	byte SYMTYPE  = (byte)'2';            /* reserved */	byte CHRTYPE  = (byte)'3';            /* character special */	byte BLKTYPE  = (byte)'4';            /* block special */	byte DIRTYPE  = (byte)'5';            /* directory */	byte FIFOTYPE = (byte)'6';            /* FIFO special */	byte CONTTYPE = (byte)'7';            /* reserved */	/* Bits used in the mode field, values in octal.  */    int TSUID   = 04000;          /* set UID on execution */	int TSGID   = 02000;          /* set GID on execution */	int TSVTX   = 01000;          /* reserved */	                                /* file permissions */                                    int TUREAD  = 00400;          /* read by owner */	int TUWRITE = 00200;          /* write by owner */	int TUEXEC  = 00100;          /* execute/search by owner */	int TGREAD  = 00040;          /* read by group */	int TGWRITE = 00020;          /* write by group */	int TGEXEC  = 00010;          /* execute/search by group */	int TOREAD  = 00004;          /* read by other */	int TOWRITE = 00002;          /* write by other */	int TOEXEC  = 00001;          /* execute/search by other */    	interface sparse{			char[] offSet = new char[12];		int offSetOffSet = 0;		char[] numchars = new char[12];		int numcharsOffSet = 12;	}	int SPARSES_IN_EXTRA_HEADER = 16;	int SPARSES_IN_OLDGNU_HEADER = 4;	int SPARSES_IN_SPARSE_HEADER = 21;	interface extra_header{	    	char[] aTime = new char[12];		int offSetATime = 0;				char cTime[] = new char[12];		int offSetCTime = 12;        char offSet[] = new char[12];		int offSetOffSet = 24;        char realSize[] = new char[12];		int offSetRealSize = 36;        char longNames[] = new char[4];		int offSetLongNames = 48;        char unused_Pad1[] = new char[68];                         int offSetUnused_Pad1 = 52;        char[] sp = new char[SPARSES_IN_EXTRA_HEADER];		int offSetSp = 120;                char isExtended = ' ';        int offSetIsExtended = 504;			}	     interface sparse_header{                                    // char offset        //struct sparse sp[SPARSES_IN_SPARSE_HEADER];                                     //   0                                     char isextended = ' ';              // 504                                     // 505      }    interface oldgnu_header{                                    // char offset                                     char unused_pad1[] = new char[345];        //   0       char atime[] = new char[12];               // 345       char ctime[] = new char[12];               // 357       char offset[] = new char[12];              // 369       char longnames[] = new char[4];            // 381       char unused_pad2 = ' ';             // 385       //struct sparse sp[SPARSES_IN_OLDGNU_HEADER];                                     // 386        char isextended = ' ';              // 482       char realsize[] = new char[12];            // 483                                     // 495      }    String OLDGNU_MAGIC = "ustar  " + Byte.parseByte("0");  // 7 chars and a null          // The standards committee allows only capital A through capital Z for        //user-defined expansion.           // This is a dir entry that contains the names of files that were in the        //dir at the time the dump was made.      char GNUTYPE_DUMPDIR = 'D';          // Identifies the *next* file on the tape as having a long linkname.       char GNUTYPE_LONGLINK = 'K';          // Identifies the *next* file on the tape as having a long name.       char GNUTYPE_LONGNAME = 'L';          // This is the continuation of a file that began on another volume.       char GNUTYPE_MULTIVOL = 'M';          // For storing filenames that do not fit into the main header.      char GNUTYPE_NAMES = 'N';          //This is for sparse files.       char GNUTYPE_SPARSE = 'S';          // This file is a tape/volume header.  Ignore it on extraction.      char GNUTYPE_VOLHDR = 'V';          //--------------------------------------.     //| tar Header Block, overall structure.  |     //`--------------------------------------          //tar files are made in basic blocks of this size.     int BLOCKSIZE = 512;          /*enum archive_format     {       DEFAULT_FORMAT,               /* format to be decided later       V7_FORMAT,                    /* old V7 tar format        OLDGNU_FORMAT,                /* GNU format as per before tar 1.12        POSIX_FORMAT,                 /* restricted, pure POSIX format        GNU_FORMAT                    /* POSIX format with GNU extensions      };     */          /*     union block     {       char buffer[BLOCKSIZE];       struct posix_header header;       struct extra_header extra_header;       struct oldgnu_header oldgnu_header;       struct sparse_header sparse_header;     };          */          // End of Format description.      }