/* TarConstants - Constants used by TarFS * Copyright (C) 2001 Elifarley Callado Coelho  * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License, version 2, * as published by the Free Software Foundation; * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * See the file "COPYING" for the software license.  * Elifarley Callado Coelho * Belo Horizonte, Brazil * elifarley@yahoo.com * http://www.geocities.com/elifarley/ *  * The constants were copied from the tar man pages found in LinuxPPC 2000. * I will add proper credits to the creators of the TAR format as soon as possible.  */package elifarley.io.fs.tar;/* * This interface defines the constants that are used by the classes * which manipulate tar files. * * @version	1.10, 11/24/96 * @author	David Connelly */interface TarConstants {    	static String TMAGIC = "ustar" + Byte.parseByte("0");        /* ustar and a null */	static int TMAGLEN = 6;	static String TVERSION = "00";           /* 00 and no null */	static int TVERSLEN = 2;	/* Values used in typeflag field.  */	static byte REGTYPE = (byte)'0';            /* regular file */	static byte AREGTYPE = 0;           /* regular file */	static byte LNKTYPE  = (byte)'1';            /* link */	static byte SYMTYPE  = (byte)'2';            /* reserved */	static byte CHRTYPE  = (byte)'3';            /* character special */	static byte BLKTYPE  = (byte)'4';            /* block special */	static byte DIRTYPE  = (byte)'5';            /* directory */	static byte FIFOTYPE = (byte)'6';            /* FIFO special */	static byte CONTTYPE = (byte)'7';            /* reserved */	/* Bits used in the mode field, values in octal.  */	static int TSUID   = 04000;          /* set UID on execution */	static int TSGID   = 02000;          /* set GID on execution */	static int TSVTX   = 01000;          /* reserved */	                                /* file permissions */	static int TUREAD  = 00400;          /* read by owner */	static int TUWRITE = 00200;          /* write by owner */	static int TUEXEC  = 00100;          /* execute/search by owner */	static int TGREAD  = 00040;          /* read by group */	static int TGWRITE = 00020;          /* write by group */	static int TGEXEC  = 00010;          /* execute/search by group */	static int TOREAD  = 00004;          /* read by other */	static int TOWRITE = 00002;          /* write by other */	static int TOEXEC  = 00001;          /* execute/search by other */    	interface sparse{			static char[] offSet = new char[12];		static int offSetOffSet = 0;			static char[] numchars = new char[12];		static int numcharsOffSet = 12;		}	static int SPARSES_IN_EXTRA_HEADER = 16;	static int SPARSES_IN_OLDGNU_HEADER = 4;	static int SPARSES_IN_SPARSE_HEADER = 21;	interface extra_header{	    	static char[] aTime = new char[12];		static int offSetATime = 0;					static char cTime[] = new char[12];              		static int offSetCTime = 12;	        static char offSet[] = new char[12];              		static int offSetOffSet = 24;	        static char realSize[] = new char[12];           		static int offSetRealSize = 36;	        static char longNames[] = new char[4];		static int offSetLongNames = 48;	        char unused_Pad1[] = new char[68];                         static int offSetUnused_Pad1 = 52;	        static char[] sp = new char[SPARSES_IN_EXTRA_HEADER];		static int offSetSp = 120;	                static char isExtended = ' ';        static int offSetIsExtended = 504;			}	     interface sparse_header{                                    // char offset        //struct sparse sp[SPARSES_IN_SPARSE_HEADER];                                     //   0        static char isextended = ' ';              // 504                                      // 505      };     interface oldgnu_header{                                    // char offset        static char unused_pad1[] = new char[345];        //   0        static char atime[] = new char[12];               // 345        static char ctime[] = new char[12];               // 357       static char offset[] = new char[12];              // 369        static char longnames[] = new char[4];            // 381        static char unused_pad2 = ' ';             // 385        //struct sparse sp[SPARSES_IN_OLDGNU_HEADER];                                     // 386        static char isextended = ' ';              // 482       static char realsize[] = new char[12];            // 483                                      // 495      };     static String OLDGNU_MAGIC = "ustar  " + Byte.parseByte("0");  // 7 chars and a null           // The standards committee allows only capital A through capital Z for        //user-defined expansion.           // This is a dir entry that contains the names of files that were in the        //dir at the time the dump was made.      static char GNUTYPE_DUMPDIR = 'D';          // Identifies the *next* file on the tape as having a long linkname.       static char GNUTYPE_LONGLINK = 'K';          // Identifies the *next* file on the tape as having a long name.       static char GNUTYPE_LONGNAME = 'L';          // This is the continuation of a file that began on another volume.       static char GNUTYPE_MULTIVOL = 'M';          // For storing filenames that do not fit into the main header.      static char GNUTYPE_NAMES = 'N';          //This is for sparse files.       static char GNUTYPE_SPARSE = 'S';          // This file is a tape/volume header.  Ignore it on extraction.      static char GNUTYPE_VOLHDR = 'V';          //--------------------------------------.     //| tar Header Block, overall structure.  |     //`--------------------------------------          //tar files are made in basic blocks of this size.     static int BLOCKSIZE = 512;          /*enum archive_format     {       DEFAULT_FORMAT,               /* format to be decided later       V7_FORMAT,                    /* old V7 tar format        OLDGNU_FORMAT,                /* GNU format as per before tar 1.12        POSIX_FORMAT,                 /* restricted, pure POSIX format        GNU_FORMAT                    /* POSIX format with GNU extensions      };     */          /*     union block     {       char buffer[BLOCKSIZE];       struct posix_header header;       struct extra_header extra_header;       struct oldgnu_header oldgnu_header;       struct sparse_header sparse_header;     };          */          // End of Format description.      }