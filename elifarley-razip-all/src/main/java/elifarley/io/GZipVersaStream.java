/* GZipVersaStream -- Returns a VersaStream from a stream in GZIP format.Portions of this software are Copyright (c) 2001, Elifarley Callado Coelho -http://www.geocities.com/elifarley/LicenseRedistribution and use in source and binary forms,with or without modification, are permitted provided thatthe following conditions are met:*	Redistributions of source code must retain the abovecopyright notice, this list of conditions and the followingdisclaimer. *	Redistributions in binary form must reproduce the abovecopyright notice, this list of conditions and the followingdisclaimer in the documentation, about box and/or othermaterials provided with the distribution. *	No personal names or organizations names associatedwith the Indy project may be used to endorse or promoteproducts derived from this software without specific priorwritten permission of the specific individual ororganization. THIS SOFTWARE IS PROVIDED BY ITS AUTHOR (ELIFARLEY CALLADO COELHO) "AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Portions of this software are based on Jazzlib 0.0.1 (http://jazzlib.sourceforge.net/) */ package elifarley.io; import java.io.*;import java.util.zip.CRC32;import java.util.zip.CheckedInputStream;import java.util.zip.Inflater;public class GZipVersaStream extends VersaStream {      	/* Magic number found at start of GZIP header */    public final static int GZIP_MAGIC = 0x8B1F;	/*    The flag byte is divided into individual bits as follows:	bit 0   FTEXT	bit 1   FHCRC	bit 2   FEXTRA	bit 3   FNAME	bit 4   FCOMMENT	bit 5   reserved	bit 6   reserved	bit 7   reserved	*/	public static final int FTEXT 		= 1<<0;	public static final int FHCRC 		= 1<<1;	public static final int FEXTRA		= 1<<2;	public static final int FNAME 		= 1<<3;	public static final int FCOMMENT 	= 1<<4;	protected VersaStream vs;	protected InflaterVersaStream ivs;	protected int infBufSize = 4096;	protected boolean verifyCRC = false;    protected CRC32 crc = new CRC32();    protected boolean eos;    public GZipVersaStream(VersaStream vs, int infBufSize) throws IOException {				this.compressionFormat = CF_GZIP;		this.infBufSize = infBufSize;		this.vs = vs;		readHeader();		//crc.reset();				vs.seek(-4, FROM_END);		long fSize = vs.readUnsignedInt();				long iSize = (fSize & 0xFF) << 24;		iSize |= ( (fSize >> 8) & 0xFF) << 16;		iSize |= ( (fSize >> 16) & 0xFF) << 8;		iSize |= ( (fSize >> 24) & 0xFF) << 0;				ivs.informSize( iSize );    	System.out.println("uncompressed size: " + ivs.getSize() );    }    public GZipVersaStream(VersaStream vs) throws IOException {		this(vs, 4096);	}	    public boolean canRead() {    	return true;    }    public boolean canWrite() {    	return false; // for now    }    public boolean canSeekBackwards() {    	return true;    }    public boolean canSeekForward() {    	return true;    }    public boolean canSeekFromEnd() {    	return true;    }    public boolean canSetSize() {    	return false; // not yet    }    public boolean markSupported() {		return true;    }	public long getPosition() throws IOException {		return ivs.getPosition();	}	public void setPosition(long pos) throws IOException {		ivs.setPosition(pos);	}	    public void setSize(long newSize) throws IOException{		ivs.setSize(newSize);    }	public long seek(long offset, short origin) throws IOException {		return ivs.seek(offset, origin);	}    public int read() throws IOException {		byte[] b = new byte[1];		return read(b, 0, 1) == -1 ? -1 : b[0] & 0xff;    }    public int read(byte[] buf, int off, int len) throws IOException {		len = ivs.read(buf, off, len);		if (len == -1) {		    readTrailer();		    //eos = true;		} else {		    //crc.update(buf, off, len);		}		return len;    }	public synchronized void write(int b) throws IOException {		throw new IOException("Writing not supported yet");	}	    /**     * Closes the input stream.     * @exception IOException if an I/O error has occurred     */    public void close() throws IOException {		ivs.close();		vs.close();		eos = true;    }    private void readHeader() throws IOException {		vs.setPosition(0);				CRC32 headCRC = new CRC32();		/* 1. Check the two magic bytes */		int magic;		try {			magic = vs.readUnsignedShort();		} catch (EOFException eofe) {			eos = true;			return;		}		headCRC.update(magic);		magic = ( ( magic >> 8 ) & 0xFF ) | ( (magic & 0xFF) << 8);		if(magic != GZIP_MAGIC)		{			throw new IOException("Error in GZIP header, signature bytes doesn't match");		}		/* 2. Check the compression type (must be 8) */		int CM = vs.read();		if(CM != 8)		{			throw new IOException("Error in GZIP header, data not in deflate format");		}		headCRC.update(CM);		/* 3. Check the flags */		int flags = vs.read();				if(flags < 0)			throw new EOFException("Early EOF in GZIP header");				headCRC.update(flags);		/* 3.1 Check the reserved bits are zero */		if((flags & 0xd0) != 0)		{		throw new IOException("Reserved flag bits in GZIP header != 0");		}		/* 4.-6. Skip the modification time, extra flags, and OS type */		for (int i=0; i< 6; i++)		{		int readByte = vs.read();		if (readByte < 0)		throw new EOFException("Early EOF in GZIP header");			headCRC.update(readByte);		}		/* 7. Read extra field */		if((flags & FEXTRA) != 0)		{		/* Skip subfield id */		for (int i=0; i< 2; i++)		{		int readByte = vs.read();		if (readByte < 0)		throw new EOFException("Early EOF in GZIP header");		headCRC.update(readByte);		}		if (vs.read() < 0 || vs.read() < 0)		throw new EOFException("Early EOF in GZIP header");		int len1, len2, extraLen;		len1 = vs.read();		len2 = vs.read();		if((len1 < 0) || (len2 < 0))		throw new EOFException("Early EOF in GZIP header");		headCRC.update(len1);		headCRC.update(len2);		extraLen = (len1 << 8) | len2;		for(int i = 0; i < extraLen;i++)		{		int readByte = vs.read();		if (readByte < 0)		throw new EOFException("Early EOF in GZIP header");		headCRC.update(readByte);		}		}		/* 8. Read file name */		if((flags & FNAME) != 0)		{		int readByte;		while( (readByte = vs.read()) > 0)		headCRC.update(readByte);		if(readByte < 0)		throw new EOFException("Early EOF in GZIP file name");		headCRC.update(readByte);		}		/* 9. Read comment */		if((flags & FCOMMENT) != 0)		{		int readByte;		while( (readByte = vs.read()) > 0)		headCRC.update(readByte);		if(readByte < 0)		throw new EOFException("Early EOF in GZIP comment");		headCRC.update(readByte);		}		/* 10. Read header CRC */		if((flags & FHCRC) != 0)		{			int tempByte;			int crcval = vs.read();			if(crcval < 0)				throw new EOFException("Early EOF in GZIP header");			tempByte = vs.read();			if(tempByte < 0)				throw new EOFException("Early EOF in GZIP header");			crcval = (crcval << 8) | tempByte;			if (crcval != ((int) headCRC.getValue() & 0xffff))				throw new IOException("Header CRC value mismatch");		}		this.ivs = new InflaterVersaStream(vs.getInputStream(), new Inflater(true), infBufSize);    }    private void readTrailer() throws IOException {		InputStream in = this.vs.getInputStream();		int n = ivs.inf.getRemaining();		byte[] footer = new byte[8];		int avail = ivs.inf.getRemaining();		if (avail > 8)		avail = 8;		System.arraycopy(ivs.buf, ivs.len - ivs.inf.getRemaining(), footer, 0, avail);		int needed = 8 - avail;		while (needed > 0)		{			int count = in.read(footer, 8-needed, needed);			if (count <= 0)				throw new EOFException("Early EOF in GZIP footer");			needed -= count; //Jewel Jan 16		}		int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8)		| ((footer[2] & 0xff) << 16) | (footer[3] << 24);		if ( verifyCRC && (crcval != (int) crc.getValue()) )			throw new IOException("GZIP crc sum mismatch, theirs \"" + Integer.toHexString(crcval) + "\" and ours \"" + Integer.toHexString( (int) crc.getValue()));		int total = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8)		| ((footer[6] & 0xff) << 16) | (footer[7] << 24);		if (total != ivs.inf.getTotalOut())			throw new IOException("Number of bytes mismatch");    }    }