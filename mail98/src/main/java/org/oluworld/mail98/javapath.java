package org.oluworld.mail98;

import org.python.core.*;

public class javapath extends java.lang.Object {

    static String[] jpy$properties = new String[]{"python.modules.builtin", "exceptions:org.python.core.exceptions", "python.options.showJavaExceptions", "true"};
    static String[] jpy$packages = new String[]{"java.io", null, "javax.swing.text", null, "javax.swing.tree", null, "java.awt.print", null, "java.awt.peer", null, "java.awt.font", null, "javax.swing.colorchooser", null, "java.awt.datatransfer", null, "java.awt.geom", null, "java.lang", null, "javax.swing.undo", null, "java.awt", "Choice,PrintGraphics,ImageCapabilities,DisplayMode,Cursor,GradientPaint,Robot,GridLayout,CheckboxMenuItem,Window,GraphicsConfiguration,BasicStroke,AWTEvent,TextField,AWTException,Menu,Insets,Shape,PointerInfo,GraphicsEnvironment,MenuShortcut,LayoutManager2,AlphaComposite,GridBagLayout,Frame,Font,KeyEventPostProcessor,Scrollbar,Panel,MouseInfo,FileDialog,ScrollPaneAdjustable,Event,Checkbox,ItemSelectable,DefaultKeyboardFocusManager,GraphicsConfigTemplate,FontMetrics,ComponentOrientation,BufferCapabilities,AWTKeyStroke,DefaultFocusTraversalPolicy,PaintContext,List,CompositeContext,MenuContainer,TextComponent,KeyEventDispatcher,PrintJob,SystemColor,ActiveEvent,TextArea,GraphicsDevice,Adjustable,FontFormatException,Rectangle,FocusTraversalPolicy,RenderingHints,AWTPermission,Component,TexturePaint,AWTEventMulticaster,Stroke,MediaTracker,BorderLayout,Point,HeadlessException,Paint,ScrollPane,Graphics,MenuBar,Color,FlowLayout,Label,Button,Transparency,Graphics2D,GridBagConstraints,IllegalComponentStateException,CardLayout,KeyboardFocusManager,CheckboxGroup,Toolkit,Dialog,Polygon,PageAttributes,Container,Composite,JobAttributes,MenuComponent,Canvas,ContainerOrderFocusTraversalPolicy,EventQueue,PopupMenu,LayoutManager,MenuItem,Image,Dimension,AWTError", "javax.swing.event", "PopupMenuListener,HyperlinkEvent,MenuKeyEvent,UndoableEditEvent,MenuDragMouseListener,ChangeEvent,TreeExpansionEvent,InternalFrameListener,TreeWillExpandListener,AncestorEvent,ListSelectionEvent,HyperlinkListener,DocumentListener,TableColumnModelEvent,AncestorListener,TreeModelEvent,TableModelEvent,TreeExpansionListener,ListSelectionListener,InternalFrameEvent,MouseInputListener,TreeSelectionEvent,SwingPropertyChangeSupport,ChangeListener,ListDataEvent,TableModelListener,CaretEvent,PopupMenuEvent,EventListenerList,MenuEvent,MouseInputAdapter,UndoableEditListener,ListDataListener,MenuListener,DocumentEvent,MenuDragMouseEvent,InternalFrameAdapter,CaretListener,TreeModelListener,MenuKeyListener,TableColumnModelListener,CellEditorListener,TreeSelectionListener", "javax.swing.border", null, "javax.swing.filechooser", null, "java.awt.im", null, "java.awt.image", null, "javax.swing.table", "TableColumnModel,TableColumn,TableCellEditor,DefaultTableModel,AbstractTableModel,DefaultTableColumnModel,JTableHeader,TableModel,TableCellRenderer,DefaultTableCellRenderer", "java.awt.dnd", null, "java.awt.color", null, "java.awt.event", "ComponentEvent,PaintEvent,InvocationEvent,FocusListener,HierarchyBoundsAdapter,MouseListener,MouseWheelEvent,FocusEvent,WindowEvent,AdjustmentListener,MouseEvent,ComponentListener,ItemEvent,KeyListener,HierarchyEvent,KeyEvent,InputEvent,WindowListener,HierarchyBoundsListener,MouseMotionListener,ActionListener,WindowAdapter,WindowStateListener,InputMethodEvent,MouseWheelListener,TextListener,KeyAdapter,AdjustmentEvent,ItemListener,ContainerAdapter,ActionEvent,InputMethodListener,MouseAdapter,FocusAdapter,TextEvent,HierarchyListener,ContainerListener,AWTEventListenerProxy,WindowFocusListener,ComponentAdapter,MouseMotionAdapter,AWTEventListener,ContainerEvent", "javax.swing", "WindowConstants,ComboBoxModel,DefaultListModel,PopupFactory,Timer,JRootPane,AbstractAction,DebugGraphics,DefaultButtonModel,ListSelectionModel,JMenuItem,ScrollPaneConstants,ComponentInputMap,DefaultComboBoxModel,UIManager,JTextField,AbstractButton,MutableComboBoxModel,AbstractCellEditor,SpinnerModel,JLabel,OverlayLayout,DesktopManager,JColorChooser,ToolTipManager,DefaultListCellRenderer,BoxLayout,SpringLayout,SwingUtilities,JTabbedPane,ProgressMonitorInputStream,JInternalFrame,ImageIcon,JRadioButton,TransferHandler,Box,SizeRequirements,InternalFrameFocusTraversalPolicy,LookAndFeel,ViewportLayout,JProgressBar,ButtonGroup,JToolBar,JDialog,BorderFactory,JTextArea,Renderer,JSeparator,JApplet,MenuElement,JToggleButton,JPasswordField,SpinnerDateModel,ListCellRenderer,JTree,InputVerifier,AbstractListModel,JMenu,JComboBox,MenuSelectionManager,JScrollPane,UIDefaults,FocusManager,SingleSelectionModel,InputMap,CellEditor,JFrame,JFormattedTextField,JTable,Spring,ButtonModel,JComponent,ComboBoxEditor,RootPaneContainer,SortingFocusTraversalPolicy,SpinnerListModel,JSpinner,BoundedRangeModel,JCheckBox,DefaultBoundedRangeModel,JMenuBar,JPopupMenu,ProgressMonitor,Popup,CellRendererPane,RepaintManager,Scrollable,AbstractSpinnerModel,ListModel,DefaultSingleSelectionModel,GrayFilter,KeyStroke,SizeSequence,UnsupportedLookAndFeelException,JLayeredPane,LayoutFocusTraversalPolicy,JCheckBoxMenuItem,ScrollPaneLayout,DefaultDesktopManager,JSplitPane,SpinnerNumberModel,JPanel,JDesktopPane,DefaultFocusManager,JRadioButtonMenuItem,JWindow,JToolTip,JSlider,JList,Action,JViewport,JTextPane,JScrollBar,JEditorPane,DefaultListSelectionModel,JFileChooser,JButton,DefaultCellEditor,SwingConstants,JOptionPane,Icon,ActionMap", "javax.swing.plaf", null};

    public static class _PyInner extends PyFunctionTable implements PyRunnable {

        private static PyObject s$0;
        private static PyObject s$1;
        private static PyObject s$2;
        private static PyObject s$3;
        private static PyObject s$4;
        private static PyObject s$5;
        private static PyObject i$6;
        private static PyObject i$7;
        private static PyObject s$8;
        private static PyObject s$9;
        private static PyObject s$10;
        private static PyObject s$11;
        private static PyObject s$12;
        private static PyObject s$13;
        private static PyObject s$14;
        private static PyObject s$15;
        private static PyObject s$16;
        private static PyObject s$17;
        private static PyObject s$18;
        private static PyObject s$19;
        private static PyObject s$20;
        private static PyObject s$21;
        private static PyObject i$22;
        private static PyObject s$23;
        private static PyObject s$24;
        private static PyObject s$25;
        private static PyObject s$26;
        private static PyObject s$27;
        private static PyObject s$28;
        private static PyObject s$29;
        private static PyFunctionTable funcTable;
        private static PyCode c$0_dirname;
        private static PyCode c$1_basename;
        private static PyCode c$2_split;
        private static PyCode c$3_splitext;
        private static PyCode c$4_splitdrive;
        private static PyCode c$5_exists;
        private static PyCode c$6_isabs;
        private static PyCode c$7_isfile;
        private static PyCode c$8_isdir;
        private static PyCode c$9_join;
        private static PyCode c$10_normcase;
        private static PyCode c$11_commonprefix;
        private static PyCode c$12_islink;
        private static PyCode c$13_samefile;
        private static PyCode c$14_ismount;
        private static PyCode c$15_walk;
        private static PyCode c$16_expanduser;
        private static PyCode c$17_getuser;
        private static PyCode c$18_gethome;
        private static PyCode c$19_normpath;
        private static PyCode c$20_abspath;
        private static PyCode c$21_getsize;
        private static PyCode c$22_main;

        private static void initConstants() {
            s$0 = Py.newString("Common pathname manipulations, JDK version.\012\012Instead of importing this module directly, import os and refer to this\012module as os.path.\012\012");
            s$1 = Py.newString("Return the directory component of a pathname");
            s$2 = Py.newString("");
            s$3 = Py.newString("Return the final component of a pathname");
            s$4 = Py.newString("Split a pathname.\012\012    Return tuple \"(head, tail)\" where \"tail\" is everything after the\012    final slash.  Either part may be empty.\012\012    ");
            s$5 = Py.newString("Split the extension from a pathname.\012\012    Extension is everything from the last dot to the end.  Return\012    \"(root, ext)\", either part may be empty.\012\012    ");
            i$6 = Py.newInteger(0);
            i$7 = Py.newInteger(1);
            s$8 = Py.newString(".");
            s$9 = Py.newString("Split a pathname into drive and path.\012\012    On JDK, drive is always empty.\012    XXX This isn't correct for JDK on DOS/Windows!\012\012    ");
            s$10 = Py.newString("Test whether a path exists.\012\012    Returns false for broken symbolic links.\012\012    ");
            s$11 = Py.newString("Test whether a path is absolute");
            s$12 = Py.newString("Test whether a path is a regular file");
            s$13 = Py.newString("Test whether a path is a directory");
            s$14 = Py.newString("Join two or more pathname components, inserting os.sep as needed");
            s$15 = Py.newString("Normalize case of pathname.\012\012    XXX Not done right under JDK.\012\012    ");
            s$16 = Py.newString("Given a list of pathnames, return the longest common leading component");
            s$17 = Py.newString("Test whether a path is a symbolic link.\012\012    XXX This incorrectly always returns false under JDK.\012\012    ");
            s$18 = Py.newString("Test whether two pathnames reference the same actual file");
            s$19 = Py.newString("Test whether a path is a mount point.\012\012    XXX This incorrectly always returns false under JDK.\012\012    ");
            s$20 = Py.newString("Walk a directory tree.\012\012    walk(top,func,args) calls func(arg, d, files) for each directory\012    \"d\" in the tree rooted at \"top\" (including \"top\" itself).  \"files\"\012    is a list of all the files and subdirs in directory \"d\".\012\012    ");
            s$21 = Py.newString("~");
            i$22 = Py.newInteger(2);
            s$23 = Py.newString("user.name");
            s$24 = Py.newString("user.home");
            s$25 = Py.newString("Normalize path, eliminating double slashes, etc.");
            s$26 = Py.newString("\\");
            s$27 = Py.newString("/");
            s$28 = Py.newString("No such file or directory");
            s$29 = Py.newString("/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py");
            funcTable = new _PyInner();
            c$0_dirname = Py.newCode(1, new String[]{"path", "result"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "dirname", false, false, funcTable, 0, null, null, 0, 1);
            c$1_basename = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "basename", false, false, funcTable, 1, null, null, 0, 1);
            c$2_split = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "split", false, false, funcTable, 2, null, null, 0, 1);
            c$3_splitext = Py.newCode(1, new String[]{"path", "i", "c", "n"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "splitext", false, false, funcTable, 3, null, null, 0, 1);
            c$4_splitdrive = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "splitdrive", false, false, funcTable, 4, null, null, 0, 1);
            c$5_exists = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "exists", false, false, funcTable, 5, null, null, 0, 1);
            c$6_isabs = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "isabs", false, false, funcTable, 6, null, null, 0, 1);
            c$7_isfile = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "isfile", false, false, funcTable, 7, null, null, 0, 1);
            c$8_isdir = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "isdir", false, false, funcTable, 8, null, null, 0, 1);
            c$9_join = Py.newCode(2, new String[]{"path", "args", "a", "g", "f"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "join", true, false, funcTable, 9, null, null, 0, 1);
            c$10_normcase = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "normcase", false, false, funcTable, 10, null, null, 0, 1);
            c$11_commonprefix = Py.newCode(1, new String[]{"m", "i", "item", "prefix"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "commonprefix", false, false, funcTable, 11, null, null, 0, 1);
            c$12_islink = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "islink", false, false, funcTable, 12, null, null, 0, 1);
            c$13_samefile = Py.newCode(2, new String[]{"path", "path2", "f", "f2"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "samefile", false, false, funcTable, 13, null, null, 0, 1);
            c$14_ismount = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "ismount", false, false, funcTable, 14, null, null, 0, 1);
            c$15_walk = Py.newCode(3, new String[]{"top", "func", "arg", "name", "names"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "walk", false, false, funcTable, 15, null, null, 0, 1);
            c$16_expanduser = Py.newCode(1, new String[]{"path", "c"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "expanduser", false, false, funcTable, 16, null, null, 0, 1);
            c$17_getuser = Py.newCode(0, new String[]{}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "getuser", false, false, funcTable, 17, null, null, 0, 1);
            c$18_gethome = Py.newCode(0, new String[]{}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "gethome", false, false, funcTable, 18, null, null, 0, 1);
            c$19_normpath = Py.newCode(1, new String[]{"path", "comps", "i", "pardir", "string", "slashes", "curdir", "sep"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "normpath", false, false, funcTable, 19, null, null, 0, 1);
            c$20_abspath = Py.newCode(1, new String[]{"path"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "abspath", false, false, funcTable, 20, null, null, 0, 1);
            c$21_getsize = Py.newCode(1, new String[]{"path", "size", "f"}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "getsize", false, false, funcTable, 21, null, null, 0, 1);
            c$22_main = Py.newCode(0, new String[]{}, "/fm/appz/jython_2.1a3__GG/runtime/Lib/javapath.py", "main", false, false, funcTable, 22, null, null, 0, 0);
        }

        public PyCode getMain() {
            if (c$22_main == null) {
                _PyInner.initConstants();
            }
            return c$22_main;
        }

        public PyObject call_function(int index, PyFrame frame) {
            switch (index) {
                case 0:
                    return _PyInner.dirname$1(frame);
                case 1:
                    return _PyInner.basename$2(frame);
                case 2:
                    return _PyInner.split$3(frame);
                case 3:
                    return _PyInner.splitext$4(frame);
                case 4:
                    return _PyInner.splitdrive$5(frame);
                case 5:
                    return _PyInner.exists$6(frame);
                case 6:
                    return _PyInner.isabs$7(frame);
                case 7:
                    return _PyInner.isfile$8(frame);
                case 8:
                    return _PyInner.isdir$9(frame);
                case 9:
                    return _PyInner.join$10(frame);
                case 10:
                    return _PyInner.normcase$11(frame);
                case 11:
                    return _PyInner.commonprefix$12(frame);
                case 12:
                    return _PyInner.islink$13(frame);
                case 13:
                    return _PyInner.samefile$14(frame);
                case 14:
                    return _PyInner.ismount$15(frame);
                case 15:
                    return _PyInner.walk$16(frame);
                case 16:
                    return _PyInner.expanduser$17(frame);
                case 17:
                    return _PyInner.getuser$18(frame);
                case 18:
                    return _PyInner.gethome$19(frame);
                case 19:
                    return _PyInner.normpath$20(frame);
                case 20:
                    return _PyInner.abspath$21(frame);
                case 21:
                    return _PyInner.getsize$22(frame);
                case 22:
                    return _PyInner.main$23(frame);
                default:
                    return null;
            }
        }

        private static PyObject dirname$1(PyFrame frame) {
            /* Return the directory component of a pathname */
            frame.setlocal(1, frame.getglobal("File").__call__(frame.getlocal(0)).invoke("getParent"));
            if (frame.getlocal(1).__not__().__nonzero__()) {
                if (frame.getglobal("isabs").__call__(frame.getlocal(0)).__nonzero__()) {
                    frame.setlocal(1, frame.getlocal(0));
                } else {
                    frame.setlocal(1, s$2);
                }
            }
            return frame.getlocal(1);
        }

        private static PyObject basename$2(PyFrame frame) {
            /* Return the final component of a pathname */
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("getName");
        }

        private static PyObject split$3(PyFrame frame) {
            /* Split a pathname.
            
                Return tuple "(head, tail)" where "tail" is everything after the
                final slash.  Either part may be empty.
            
             */
            return new PyTuple(new PyObject[]{frame.getglobal("dirname").__call__(frame.getlocal(0)), frame.getglobal("basename").__call__(frame.getlocal(0))});
        }

        private static PyObject splitext$4(PyFrame frame) {
            // Temporary Variables
            int t$0$int;
            PyObject t$0$PyObject, t$1$PyObject;

            // Code
            /* Split the extension from a pathname.
            
                Extension is everything from the last dot to the end.  Return
                "(root, ext)", either part may be empty.
            
             */
            frame.setlocal(1, i$6);
            frame.setlocal(3, i$7.__neg__());
            t$0$int = 0;
            t$1$PyObject = frame.getlocal(0);
            while ((t$0$PyObject = t$1$PyObject.__finditem__(t$0$int++)) != null) {
                frame.setlocal(2, t$0$PyObject);
                if (frame.getlocal(2)._eq(s$8).__nonzero__()) {
                    frame.setlocal(3, frame.getlocal(1));
                }
                frame.setlocal(1, frame.getlocal(1)._add(i$7));
            }
            if (frame.getlocal(3)._lt(i$6).__nonzero__()) {
                return new PyTuple(new PyObject[]{frame.getlocal(0), s$2});
            } else {
                return new PyTuple(new PyObject[]{frame.getlocal(0).__getslice__(null, frame.getlocal(3), null), frame.getlocal(0).__getslice__(frame.getlocal(3), null, null)});
            }
        }

        private static PyObject splitdrive$5(PyFrame frame) {
            /* Split a pathname into drive and path.
            
                On JDK, drive is always empty.
                XXX This isn't correct for JDK on DOS/Windows!
            
             */
            return new PyTuple(new PyObject[]{s$2, frame.getlocal(0)});
        }

        private static PyObject exists$6(PyFrame frame) {
            /* Test whether a path exists.
            
                Returns false for broken symbolic links.
            
             */
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("exists");
        }

        private static PyObject isabs$7(PyFrame frame) {
            /* Test whether a path is absolute */
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("isAbsolute");
        }

        private static PyObject isfile$8(PyFrame frame) {
            /* Test whether a path is a regular file */
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("isFile");
        }

        private static PyObject isdir$9(PyFrame frame) {
            /* Test whether a path is a directory */
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("isDirectory");
        }

        private static PyObject join$10(PyFrame frame) {
            // Temporary Variables
            int t$0$int;
            PyObject t$0$PyObject, t$1$PyObject, t$2$PyObject;

            // Code
            /* Join two or more pathname components, inserting os.sep as needed */
            frame.setlocal(4, frame.getglobal("File").__call__(frame.getlocal(0)));
            t$0$int = 0;
            t$1$PyObject = frame.getlocal(1);
            while ((t$0$PyObject = t$1$PyObject.__finditem__(t$0$int++)) != null) {
                frame.setlocal(2, t$0$PyObject);
                frame.setlocal(3, frame.getglobal("File").__call__(frame.getlocal(2)));
                if (((t$2$PyObject = frame.getlocal(3).invoke("isAbsolute")).__nonzero__() ? t$2$PyObject : frame.getglobal("len").__call__(frame.getlocal(4).invoke("getPath"))._eq(i$6)).__nonzero__()) {
                    frame.setlocal(4, frame.getlocal(3));
                } else {
                    frame.setlocal(4, frame.getglobal("File").__call__(frame.getlocal(4), frame.getlocal(2)));
                }
            }
            return frame.getlocal(4).invoke("getPath");
        }

        private static PyObject normcase$11(PyFrame frame) {
            /* Normalize case of pathname.
            
                XXX Not done right under JDK.
            
             */
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("getPath");
        }

        private static PyObject commonprefix$12(PyFrame frame) {
            // Temporary Variables
            int t$0$int, t$1$int;
            PyObject t$0$PyObject, t$1$PyObject, t$2$PyObject, t$3$PyObject;

            // Code
            /* Given a list of pathnames, return the longest common leading component */
            if (frame.getlocal(0).__not__().__nonzero__()) {
                return s$2;
            }
            frame.setlocal(3, frame.getlocal(0).__getitem__(i$6));
            t$0$int = 0;
            t$1$PyObject = frame.getlocal(0);
            while ((t$0$PyObject = t$1$PyObject.__finditem__(t$0$int++)) != null) {
                frame.setlocal(2, t$0$PyObject);
                t$1$int = 0;
                t$3$PyObject = frame.getglobal("range").__call__(frame.getglobal("len").__call__(frame.getlocal(3)));
                while ((t$2$PyObject = t$3$PyObject.__finditem__(t$1$int++)) != null) {
                    frame.setlocal(1, t$2$PyObject);
                    if (frame.getlocal(3).__getslice__(null, frame.getlocal(1)._add(i$7), null)._ne(frame.getlocal(2).__getslice__(null, frame.getlocal(1)._add(i$7), null)).__nonzero__()) {
                        frame.setlocal(3, frame.getlocal(3).__getslice__(null, frame.getlocal(1), null));
                        if (frame.getlocal(1)._eq(i$6).__nonzero__()) {
                            return s$2;
                        }
                        break;
                    }
                }
            }
            return frame.getlocal(3);
        }

        private static PyObject islink$13(PyFrame frame) {
            /* Test whether a path is a symbolic link.
            
                XXX This incorrectly always returns false under JDK.
            
             */
            return i$6;
        }

        private static PyObject samefile$14(PyFrame frame) {
            /* Test whether two pathnames reference the same actual file */
            frame.setlocal(2, frame.getglobal("File").__call__(frame.getlocal(0)));
            frame.setlocal(3, frame.getglobal("File").__call__(frame.getlocal(1)));
            return frame.getlocal(2).invoke("getCanonicalPath")._eq(frame.getlocal(3).invoke("getCanonicalPath"));
        }

        private static PyObject ismount$15(PyFrame frame) {
            /* Test whether a path is a mount point.
            
                XXX This incorrectly always returns false under JDK.
            
             */
            return i$6;
        }

        private static PyObject walk$16(PyFrame frame) {
            // Temporary Variables
            int t$0$int;
            PyObject t$0$PyObject, t$1$PyObject, t$2$PyObject;
            PyException t$0$PyException;

            // Code
            /* Walk a directory tree.
            
                walk(top,func,args) calls func(arg, d, files) for each directory
                "d" in the tree rooted at "top" (including "top" itself).  "files"
                is a list of all the files and subdirs in directory "d".
            
             */
            try {
                frame.setlocal(4, frame.getglobal("os").__getattr__("listdir").__call__(frame.getlocal(0)));
            } catch (Throwable x$0) {
                t$0$PyException = Py.setException(x$0, frame);
                if (Py.matchException(t$0$PyException, frame.getglobal("os").__getattr__("error"))) {
                    return Py.None;
                } else {
                    throw t$0$PyException;
                }
            }
            frame.getlocal(1).__call__(frame.getlocal(2), frame.getlocal(0), frame.getlocal(4));
            t$0$int = 0;
            t$1$PyObject = frame.getlocal(4);
            while ((t$0$PyObject = t$1$PyObject.__finditem__(t$0$int++)) != null) {
                frame.setlocal(3, t$0$PyObject);
                frame.setlocal(3, frame.getglobal("join").__call__(frame.getlocal(0), frame.getlocal(3)));
                if (((t$2$PyObject = frame.getglobal("isdir").__call__(frame.getlocal(3))).__nonzero__() ? frame.getglobal("islink").__call__(frame.getlocal(3)).__not__() : t$2$PyObject).__nonzero__()) {
                    frame.getglobal("walk").__call__(frame.getlocal(3), frame.getlocal(1), frame.getlocal(2));
                }
            }
            return Py.None;
        }

        private static PyObject expanduser$17(PyFrame frame) {
            if (frame.getlocal(0).__getslice__(null, i$7, null)._eq(s$21).__nonzero__()) {
                frame.setlocal(1, frame.getlocal(0).__getslice__(i$7, i$22, null));
                if (frame.getlocal(1).__not__().__nonzero__()) {
                    return frame.getglobal("gethome").__call__();
                }
                if (frame.getlocal(1)._eq(frame.getglobal("os").__getattr__("sep")).__nonzero__()) {
                    return frame.getglobal("File").__call__(frame.getglobal("gethome").__call__(), frame.getlocal(0).__getslice__(i$22, null, null)).invoke("getPath");
                }
            }
            return frame.getlocal(0);
        }

        private static PyObject getuser$18(PyFrame frame) {
            return frame.getglobal("System").__getattr__("getProperty").__call__(s$23);
        }

        private static PyObject gethome$19(PyFrame frame) {
            return frame.getglobal("System").__getattr__("getProperty").__call__(s$24);
        }

        private static PyObject normpath$20(PyFrame frame) {
            // Temporary Variables
            PyObject t$0$PyObject, t$1$PyObject;

            // Code
            /* Normalize path, eliminating double slashes, etc. */
            frame.setlocal(7, frame.getglobal("os").__getattr__("sep"));
            if (frame.getlocal(7)._eq(s$26).__nonzero__()) {
                frame.setlocal(0, frame.getlocal(0).invoke("replace", s$27, frame.getlocal(7)));
            }
            frame.setlocal(6, frame.getglobal("os").__getattr__("curdir"));
            frame.setlocal(3, frame.getglobal("os").__getattr__("pardir"));
            frame.setlocal(4, org.python.core.imp.importOne("string", frame));
            frame.setlocal(5, s$2);
            while (frame.getlocal(0).__getslice__(null, i$7, null)._eq(frame.getlocal(7)).__nonzero__()) {
                frame.setlocal(5, frame.getlocal(5)._add(frame.getlocal(7)));
                frame.setlocal(0, frame.getlocal(0).__getslice__(i$7, null, null));
            }
            frame.setlocal(1, frame.getlocal(4).__getattr__("splitfields").__call__(frame.getlocal(0), frame.getlocal(7)));
            frame.setlocal(2, i$6);
            while (frame.getlocal(2)._lt(frame.getglobal("len").__call__(frame.getlocal(1))).__nonzero__()) {
                if (frame.getlocal(1).__getitem__(frame.getlocal(2))._eq(frame.getlocal(6)).__nonzero__()) {
                    frame.getlocal(1).__delitem__(frame.getlocal(2));
                    while (((t$0$PyObject = frame.getlocal(2)._lt(frame.getglobal("len").__call__(frame.getlocal(1)))).__nonzero__() ? frame.getlocal(1).__getitem__(frame.getlocal(2))._eq(s$2) : t$0$PyObject).__nonzero__()) {
                        frame.getlocal(1).__delitem__(frame.getlocal(2));
                    }
                } else if (((t$0$PyObject = ((t$1$PyObject = frame.getlocal(1).__getitem__(frame.getlocal(2))._eq(frame.getlocal(3))).__nonzero__() ? frame.getlocal(2)._gt(i$6) : t$1$PyObject)).__nonzero__() ? frame.getlocal(1).__getitem__(frame.getlocal(2)._sub(i$7))._notin(new PyTuple(new PyObject[]{s$2, frame.getlocal(3)})) : t$0$PyObject).__nonzero__()) {
                    frame.getlocal(1).__delslice__(frame.getlocal(2)._sub(i$7), frame.getlocal(2)._add(i$7), null);
                    frame.setlocal(2, frame.getlocal(2)._sub(i$7));
                } else if (((t$0$PyObject = ((t$1$PyObject = frame.getlocal(1).__getitem__(frame.getlocal(2))._eq(s$2)).__nonzero__() ? frame.getlocal(2)._gt(i$6) : t$1$PyObject)).__nonzero__() ? frame.getlocal(1).__getitem__(frame.getlocal(2)._sub(i$7))._ne(s$2) : t$0$PyObject).__nonzero__()) {
                    frame.getlocal(1).__delitem__(frame.getlocal(2));
                } else {
                    frame.setlocal(2, frame.getlocal(2)._add(i$7));
                }
            }
            if (((t$0$PyObject = frame.getlocal(1).__not__()).__nonzero__() ? frame.getlocal(5).__not__() : t$0$PyObject).__nonzero__()) {
                frame.getlocal(1).invoke("append", frame.getlocal(6));
            }
            return frame.getlocal(5)._add(frame.getlocal(4).__getattr__("joinfields").__call__(frame.getlocal(1), frame.getlocal(7)));
        }

        private static PyObject abspath$21(PyFrame frame) {
            return frame.getglobal("File").__call__(frame.getlocal(0)).invoke("getAbsolutePath");
        }

        private static PyObject getsize$22(PyFrame frame) {
            // Temporary Variables
            PyObject t$0$PyObject;

            // Code
            frame.setlocal(2, frame.getglobal("File").__call__(frame.getlocal(0)));
            frame.setlocal(1, frame.getlocal(2).invoke("length"));
            if (((t$0$PyObject = frame.getlocal(1)._eq(i$6)).__nonzero__() ? frame.getlocal(2).invoke("exists").__not__() : t$0$PyObject).__nonzero__()) {
                throw Py.makeException(frame.getglobal("OSError").__call__(i$6, s$28, frame.getlocal(0)));
            }
            return frame.getlocal(1);
        }

        private static PyObject main$23(PyFrame frame) {
            frame.setglobal("__file__", s$29);

            PyObject[] imp_accu;
            // Code
            /* Common pathname manipulations, JDK version.
            
            Instead of importing this module directly, import os and refer to this
            module as os.path.
            
             */
            frame.setlocal("java", org.python.core.imp.importOne("java", frame));
            imp_accu = org.python.core.imp.importFrom("java.io", new String[]{"File"}, frame);
            frame.setlocal("File", imp_accu[0]);
            imp_accu = org.python.core.imp.importFrom("java.lang", new String[]{"System"}, frame);
            frame.setlocal("System", imp_accu[0]);
            frame.setlocal("os", org.python.core.imp.importOne("os", frame));
            frame.setlocal("dirname", new PyFunction(frame.f_globals, new PyObject[]{}, c$0_dirname));
            frame.setlocal("basename", new PyFunction(frame.f_globals, new PyObject[]{}, c$1_basename));
            frame.setlocal("split", new PyFunction(frame.f_globals, new PyObject[]{}, c$2_split));
            frame.setlocal("splitext", new PyFunction(frame.f_globals, new PyObject[]{}, c$3_splitext));
            frame.setlocal("splitdrive", new PyFunction(frame.f_globals, new PyObject[]{}, c$4_splitdrive));
            frame.setlocal("exists", new PyFunction(frame.f_globals, new PyObject[]{}, c$5_exists));
            frame.setlocal("isabs", new PyFunction(frame.f_globals, new PyObject[]{}, c$6_isabs));
            frame.setlocal("isfile", new PyFunction(frame.f_globals, new PyObject[]{}, c$7_isfile));
            frame.setlocal("isdir", new PyFunction(frame.f_globals, new PyObject[]{}, c$8_isdir));
            frame.setlocal("join", new PyFunction(frame.f_globals, new PyObject[]{}, c$9_join));
            frame.setlocal("normcase", new PyFunction(frame.f_globals, new PyObject[]{}, c$10_normcase));
            frame.setlocal("commonprefix", new PyFunction(frame.f_globals, new PyObject[]{}, c$11_commonprefix));
            frame.setlocal("islink", new PyFunction(frame.f_globals, new PyObject[]{}, c$12_islink));
            frame.setlocal("samefile", new PyFunction(frame.f_globals, new PyObject[]{}, c$13_samefile));
            frame.setlocal("ismount", new PyFunction(frame.f_globals, new PyObject[]{}, c$14_ismount));
            frame.setlocal("walk", new PyFunction(frame.f_globals, new PyObject[]{}, c$15_walk));
            frame.setlocal("expanduser", new PyFunction(frame.f_globals, new PyObject[]{}, c$16_expanduser));
            frame.setlocal("getuser", new PyFunction(frame.f_globals, new PyObject[]{}, c$17_getuser));
            frame.setlocal("gethome", new PyFunction(frame.f_globals, new PyObject[]{}, c$18_gethome));
            frame.setlocal("normpath", new PyFunction(frame.f_globals, new PyObject[]{}, c$19_normpath));
            frame.setlocal("abspath", new PyFunction(frame.f_globals, new PyObject[]{}, c$20_abspath));
            frame.setlocal("getsize", new PyFunction(frame.f_globals, new PyObject[]{}, c$21_getsize));
            return Py.None;
        }

    }

    public static void moduleDictInit(PyObject dict) {
        dict.__setitem__("__name__", new PyString("javapath"));
        Py.runCode(new _PyInner().getMain(), dict, dict);
    }

    public static void main(String[] args) throws Exception {
        String[] newargs = new String[args.length + 1];
        newargs[0] = "javapath";
        System.arraycopy(args, 0, newargs, 1, args.length);
        Py.runMain(javapath._PyInner.class, newargs, jpy$packages, jpy$properties, "mail98", new String[]{"DBi.Server", "etoffiutils", "DBi.Handle", "javapath", "MMS", "traceback", "stat", "string", "linecache", "DBi.__init__", "javaos", "rfc822"});
    }

}
